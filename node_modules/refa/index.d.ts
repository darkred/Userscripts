import { RegExpParser, AST } from "regexpp";
/**
 * A character is a non-negative integer.
 *
 * This is one of the core concepts of refa. Instead of operating on JavaScript strings, UTF16 character codes, or
 * Unicode code points, this library uses plain numbers instead. This makes refa agnostic to text encodings and even
 * text in general since the integers used as character may represent arbitrary concepts.
 *
 * The only 2 restrictions on the numbers that can be characters:
 *
 * 1.  They have to be non-negative integers.
 * 2.  They can be at most `Number.MAX_SAFE_INTEGER`.
 *
 * This type serves as a way to document characters. It is a clear way to signal that a value is not just any number.
 */
export type Char = number & {
	__char?: never;
};
/**
 * A word is finite sequence of {@link Char}s.
 *
 * This one of the core concepts of refa. Instead of operating on JavaScript strings, all functions operate on
 * {@link Char}s and char arrays (= words). This means that refa is agnostic to text encodings, the string
 * representation of JavaScript, and even text itself.
 *
 * This type serves as a way to document words. It should _not_ be used interchangeably with `Char[]` or `number[]`.
 */
export type Word = Char[];
/**
 * An immutable finite sequence of {@link Char}s.
 *
 * This is an immutable view on a {@link Word}.
 */
export type ReadonlyWord = readonly Char[];
/**
 * An immutable interval of {@link Char}s with inclusive ends.
 *
 * Each interval contains all characters `x` with `min <= x <= max`.
 */
export interface CharRange {
	/**
	 * The inclusive minimum of the interval.
	 *
	 * This value has to be less or equal to {@link max}.
	 */
	readonly min: Char;
	/**
	 * The inclusive maximum of the interval.
	 *
	 * This value has to be greater or equal to {@link min}.
	 */
	readonly max: Char;
}
/**
 * An immutable set of {@link Char}s represented as a sorted set of disjoint non-adjacent intervals ({@link CharRange}).
 *
 * All characters in the set have to be between 0 (inclusive) and the maximum of the set (inclusive).
 */
export class CharSet {
	/**
	 * The greatest character which can be element of the set.
	 */
	readonly maximum: Char;
	/**
	 * An array of ranges representing this character set.
	 *
	 * The array must be guaranteed to have the following properties at all times:
	 *
	 * 1. Any two ranges are disjoint.
	 * 2. Any two ranges are non-adjacent.
	 * 3. 0 <= `min` <= `max` <= `this.maximum` for all ranges.
	 * 4. All ranges are sorted by ascending `min`.
	 */
	readonly ranges: readonly CharRange[];
	/**
	 * Returns `true` if this set doesn't contain any characters.
	 */
	get isEmpty(): boolean;
	/**
	 * Returns `true` if all characters in the range from 0 to `this.maximum`, including 0 and `this.maximum`, are in
	 * the set.
	 */
	get isAll(): boolean;
	/**
	 * Returns the number of unique characters in the set.
	 *
	 * The returned number will be at least `0` and at most `this.maximum + 1`.
	 */
	get size(): number;
	/**
	 * Returns a string representation of the character set.
	 */
	toString(): string;
	/**
	 * Returns an empty character set with the given maximum.
	 *
	 * @param maximum The greatest character which can be element of the set.
	 */
	static empty(maximum: Char): CharSet;
	/**
	 * Returns a complete character set with the given maximum.
	 *
	 * @param maximum The greatest character which will be element of the set.
	 */
	static all(maximum: Char): CharSet;
	/**
	 * Returns whether this and the given character set are equivalent.
	 *
	 * Two `CharSet`s are equal if and only if:
	 *
	 * 1.  They have the same maximum.
	 * 2.  They have the same number of char ranges.
	 * 3.  For every `CharRange` in this set, there exists one `CharRange` in the other set with the same minimum and
	 *     maximum.
	 *
	 * @param other
	 */
	equals(other: CharSet): boolean;
	/**
	 * Compares this set with given set and returns an integer value describing their relation. Two equivalent set are
	 * always guaranteed to return 0.
	 *
	 * The order defined by this function is guaranteed to be a
	 * [total order](https://en.wikipedia.org/wiki/Total_order). Apart from this, no other guarantees are given.
	 *
	 * @param other
	 */
	compare(other: CharSet): number;
	/**
	 * Returns [the complement](https://en.wikipedia.org/wiki/Complement_(set_theory)) of this set.
	 *
	 * The returned set will have the same maximum as this set.
	 */
	negate(): CharSet;
	/**
	 * Returns [the union](https://en.wikipedia.org/wiki/Union_(set_theory)) of this set and all given sets and
	 * character ranges.
	 *
	 * The returned set will have the same maximum as this set.
	 *
	 * @param data
	 * @throws `RangeError` If the maximum of one of the given sets differs from the maximum of this set or if the
	 * maximum of one of the given ranges is greater than the maximum of this set.
	 */
	union(...data: (Iterable<CharRange> | CharSet)[]): CharSet;
	/**
	 * Returns [the intersection](https://en.wikipedia.org/wiki/Intersection_(set_theory)) of this set and the given set
	 * and character ranges.
	 *
	 * The returned set will have the same maximum as this set.
	 *
	 * @param set
	 * @throws `RangeError` If the maximum of the given set differs from the maximum of this set or if the maximum of
	 * one of the given ranges is greater than the maximum of this set.
	 */
	intersect(set: CharSet): CharSet;
	intersect(ranges: Iterable<CharRange>): CharSet;
	/**
	 * Returns a set that contains all characters of this set that are not in the given set.
	 *
	 * The returned set will have the same maximum as this set.
	 *
	 * @param set
	 * @throws `RangeError` If the maximum of the given set differs from the maximum of this set or if the maximum of
	 * one of the given ranges is greater than the maximum of this set.
	 */
	without(set: CharSet): CharSet;
	without(ranges: Iterable<CharRange>): CharSet;
	/**
	 * Returns whether this set contains the given character.
	 *
	 * @param character
	 */
	has(character: Char): boolean;
	isSupersetOf(other: CharSet | CharRange): boolean;
	isSubsetOf(other: CharSet | CharRange): boolean;
	/**
	 * Returns whether this set and the given set (or range) are disjoint.
	 *
	 * @param other
	 */
	isDisjointWith(other: CharSet | CharRange): boolean;
	/**
	 * Returns any one of the common characters of this set and the given set or range.
	 *
	 * If this character set is disjoint with the given character set/range, then `undefined` will be returned.
	 *
	 * @param other
	 */
	commonCharacter(other: CharSet | CharRange): Char | undefined;
}
export interface ReadonlyCharMap<T> extends Iterable<[CharRange, T]> {
	isEmpty: boolean;
	/**
	 * Returns whether the given character is a key in the map.
	 *
	 * @param char
	 */
	has(char: Char): boolean;
	/**
	 * Returns whether every character in the given range is a key in the map.
	 *
	 * This is equivalent to: `[...chars].every(char => this.has(char))`.
	 *
	 * @param chars
	 */
	hasEvery(chars: CharRange): boolean;
	/**
	 * Returns whether some character in the given range is a key in the map.
	 *
	 * This is equivalent to: `[...chars].some(char => this.has(char))`.
	 *
	 * @param chars
	 */
	hasSome(chars: CharRange): boolean;
	/**
	 * Returns the value associated with the given character of `undefined` if the character is not key in the map.
	 *
	 * @param char
	 */
	get(char: Char): T | undefined;
	/**
	 * Invokes the given callback for every item of the character map.
	 *
	 * This method is implemented more efficiently than other iterator based methods, so chose `forEach` where every
	 * possible.
	 *
	 * @param callback
	 */
	forEach(callback: (value: T, chars: CharRange, map: ReadonlyCharMap<T>) => void): void;
	keys(): Iterable<CharRange>;
	values(): Iterable<T>;
	entries(range?: CharRange): Iterable<[CharRange, T]>;
}
/**
 * A map from characters to generic values.
 *
 * The map guarantees that there are no adjacent character ranges that map to the equal values, will always be iterated
 * as one character range. The equality of values is given by a custom equal function or JavaScript's strict equality
 * operator (`===`).
 */
export class CharMap<T> implements ReadonlyCharMap<T> {
	constructor(equalFn?: (a: T, b: T) => boolean);
	get isEmpty(): boolean;
	has(char: Char): boolean;
	hasEvery(chars: CharRange): boolean;
	hasSome(chars: CharRange): boolean;
	get(char: Char): T | undefined;
	set(char: Char, value: T): void;
	/**
	 * Sets the value for all characters in the given range.
	 *
	 * This is equivalent to `[...chars].forEach(char => this.set(char, value))`.
	 *
	 * @param chars
	 * @param value
	 */
	setEvery(chars: CharRange, value: T): void;
	delete(char: Char): boolean;
	/**
	 * Deletes all characters in the given range.
	 *
	 * This is equivalent to `[...range].forEach(char => this.delete(char))`.
	 *
	 * @param range
	 */
	deleteEvery(range: CharRange): void;
	map(mapFn: (value: T, chars: CharRange, map: ReadonlyCharMap<T>) => T): void;
	mapRange(
		range: CharRange,
		mapFn: (value: T | undefined, chars: CharRange, map: ReadonlyCharMap<T>) => T | undefined
	): void;
	forEach(callback: (value: T, chars: CharRange, map: ReadonlyCharMap<T>) => void): void;
	keys(): IterableIterator<CharRange>;
	values(): IterableIterator<T>;
	entries(range?: CharRange): IterableIterator<[CharRange, T]>;
	[Symbol.iterator](): IterableIterator<[CharRange, T]>;
}
export interface FiniteAutomaton {
	/**
	 * Returns whether this FA accepts the empty language meaning that it doesn't accept any words.
	 */
	readonly isEmpty: boolean;
	/**
	 * Returns whether the formal language accepted by this FA contains finitely many words.
	 *
	 * __Note__: Finite does not mean that all words can be iterated in practice. E.g. the set of all Unicode words with
	 * 10 or less characters contains 2.6e54 many words and can be accepted by a DFA with only 11 states.
	 */
	readonly isFinite: boolean;
	/**
	 * The maximum character that is part of the alphabet of the words that this FA can accept.
	 */
	readonly maxCharacter: Char;
	/**
	 * Returns whether this FA accepts the given word.
	 *
	 * @param word The characters of the word to test.
	 */
	test(word: ReadonlyWord): boolean;
	/**
	 * Returns an iterable that will yield all words accepted by this FA. Words are yielded by ascending length.
	 *
	 * If this FA accepts infinitely many words, the iterable will never end.
	 */
	words(): Iterable<Word>;
	/**
	 * Returns an iterable that will yield all word sets accepted by this FA. Word sets are yielded by ascending length.
	 *
	 * If you analyse the words of this FA, consider using this method instead of `words` because this method will yield
	 * at most `O(n^3)` word sets while `words` will yield at most `O(n^3 * m)` words (n = number of states, m = number
	 * of possible characters).
	 *
	 * If this FA accepts infinitely many words, the iterable will never end.
	 */
	wordSets(): Iterable<CharSet[]>;
	/**
	 * Returns a string representation of this FA.
	 */
	toString(): string;
	/**
	 * Returns the AST of a regular expression that accepts the same language as this FA.
	 *
	 * @param options
	 */
	toRegex(options?: Readonly<ToRegexOptions>): NoParent<Expression>;
}
export interface ToRegexOptions {
	/**
	 * The maximum number of RE AST nodes the implementation is allowed to create.
	 *
	 * If the implementation has to create more nodes to create the RE, a `TooManyNodesError` will be thrown. This
	 * maximum will be check before any optimization passes.
	 *
	 * @default 10000
	 */
	maxNodes?: number;
	/**
	 * The maximum number of optimization passes that will be done after the initial RE AST was created.
	 *
	 * The initial AST is usually a lot more complex than necessary. Optimizations are then applied in order to minimize
	 * the AST until this limit is reached or the AST can be optimized no further.
	 *
	 * The default number of passes is implementation defined.
	 */
	maxOptimizationPasses?: number;
}
/**
 * A graph iterator for all states of an FA with final states.
 *
 * @template S The type of a state in the FA to iterate.
 * @template O The type of the value each state maps to.
 */
export interface FAIterator<S, O = Iterable<S>> {
	/**
	 * The initial state of the FA.
	 */
	readonly initial: S;
	/**
	 * Returns the value a state maps to.
	 *
	 * This function is guaranteed to be deterministic during the time the iterator is used. Subsequent invocations will
	 * always return values that are equal to the first returned value. Equality is defined by
	 * [the key equality of the Map class](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#key_equality).
	 * This function is also guaranteed to be sufficiently fast, usually `O(1)` can be assumed.
	 */
	readonly getOut: (state: S) => O;
	/**
	 * Returns whether the given state is a final state.
	 *
	 * This function is guaranteed to be deterministic during the time the iterator is used. It is also guaranteed to be
	 * sufficiently fast, usually `O(1)` can be assumed.
	 */
	readonly isFinal: (state: S) => boolean;
}
export interface TransitionIterable {
	readonly maxCharacter: Char;
	readonly transitionIterator: () => FAIterator<any, ReadonlyMap<unknown, CharSet>>;
}
export interface TransitionIterableFA extends FiniteAutomaton, TransitionIterable {
	/**
	 * Returns whether the languages of this and the other FA are disjoint.
	 *
	 * The runtime of this algorithm is `O(n * m)` (n = number of states of this NFA, m = number of states of the other
	 * FA) but it's a lot faster in practice with the worst case being very rare.
	 *
	 * Since this uses the intersection operation, you can supply intersection options.
	 *
	 * @param other
	 * @param options
	 */
	isDisjointWith(other: TransitionIterable, options?: Readonly<IntersectionOptions>): boolean;
	/**
	 * This is equivalent to `NFA.fromIntersection(this, other).wordSets()` but implemented more efficiently.
	 */
	intersectionWordSets(other: TransitionIterable, options?: Readonly<IntersectionOptions>): Iterable<CharSet[]>;
	/**
	 * This is equivalent to `NFA.fromIntersection(this, other).words()` but implemented more efficiently.
	 */
	intersectionWords(other: TransitionIterable, options?: Readonly<IntersectionOptions>): Iterable<Word>;
}
export interface IntersectionOptions {
	/**
	 * The maximum number of nodes the intersection operation is allowed to create before throwing a
	 * `TooManyNodesError`.
	 *
	 * If the maximum number of nodes is unset or set to `Infinity`, the intersection operation may create as many nodes
	 * as necessary to construct the intersection. This might cause the machine to run out of memory.
	 *
	 * @default Infinity
	 */
	maxNodes?: number;
}
/**
 * An error that is thrown when an operation causes too many nodes to be created.
 *
 * Many FA operation have the potential to create a huge number of nodes (thousands and millions) which may result in
 * the JavaScript runtime running out of memory and/or crashing. This error will thrown before that happens to safely
 * abort an otherwise resource-intensive operation.
 */
export class TooManyNodesError extends Error {}
export interface SourceLocation {
	start: number;
	end: number;
}
export interface NodeBase {
	type: Node["type"];
	parent: Node["parent"];
	source?: SourceLocation;
}
export type Element = CharacterClass | Alternation | Quantifier | Assertion;
export type Parent = Expression | Alternation | Quantifier | Assertion;
export type Node = Expression | CharacterClass | Alternation | Quantifier | Assertion | Concatenation;
export interface Alternation extends NodeBase {
	type: "Alternation";
	parent: Concatenation;
	alternatives: Concatenation[];
}
export interface Assertion extends NodeBase {
	type: "Assertion";
	parent: Concatenation;
	alternatives: Concatenation[];
	kind: "ahead" | "behind";
	negate: boolean;
}
export interface Quantifier extends NodeBase {
	type: "Quantifier";
	parent: Concatenation;
	alternatives: Concatenation[];
	lazy: boolean;
	min: number;
	max: number;
}
export interface CharacterClass extends NodeBase {
	type: "CharacterClass";
	parent: Concatenation;
	characters: CharSet;
}
export interface Expression extends NodeBase {
	type: "Expression";
	parent: null;
	alternatives: Concatenation[];
}
export interface Concatenation extends NodeBase {
	type: "Concatenation";
	parent: Parent;
	elements: Element[];
}
type NodeIdent = {
	type: Node["type"];
};
type NoParentArray<T> = {
	[K in keyof T]: NoParent<T[K]>;
};
type NoParentNode<T extends NodeIdent> = {
	[K in keyof NoParentNodePick<T>]: NoParent<NoParentNodePick<T>[K]>;
};
type NoParentNodePick<T extends NodeIdent> = Pick<T, Exclude<keyof T, "parent">>;
/**
 * A view of an AST node that hides the `parent` property.
 */
export type NoParent<T> = T extends NodeIdent ? NoParentNode<T> : T extends unknown[] ? NoParentArray<T> : T;
/**
 * Sets the `parent` properties of the given node and all of its child nodes.
 *
 * @param node
 * @param parent The parent of `node`.
 */
export function setParent<T extends Node>(node: T | NoParent<T>, parent: T["parent"]): asserts node is T;
/**
 * Sets the `source` property of the given node and all of its child nodes.
 *
 * If `source` is not a function, then the source object will be copied for all `source` properties to be set. The
 * object will be copied using the `start` and `end` properties alone, other properties will not be copied.
 *
 * @param node
 * @param source
 * @param overwrite
 */
export function setSource(
	node: NoParent<Node>,
	source: SourceLocation | (() => SourceLocation),
	overwrite?: boolean
): void;
export interface VisitAstHandler {
	onAlternationEnter?(node: Alternation): void;
	onAlternationLeave?(node: Alternation): void;
	onAssertionEnter?(node: Assertion): void;
	onAssertionLeave?(node: Assertion): void;
	onCharacterClassEnter?(node: CharacterClass): void;
	onCharacterClassLeave?(node: CharacterClass): void;
	onConcatenationEnter?(node: Concatenation): void;
	onConcatenationLeave?(node: Concatenation): void;
	onExpressionEnter?(node: Expression): void;
	onExpressionLeave?(node: Expression): void;
	onQuantifierEnter?(node: Quantifier): void;
	onQuantifierLeave?(node: Quantifier): void;
}
export interface VisitNoParentAstHandler {
	onAlternationEnter?(node: NoParent<Alternation>): void;
	onAlternationLeave?(node: NoParent<Alternation>): void;
	onAssertionEnter?(node: NoParent<Assertion>): void;
	onAssertionLeave?(node: NoParent<Assertion>): void;
	onCharacterClassEnter?(node: NoParent<CharacterClass>): void;
	onCharacterClassLeave?(node: NoParent<CharacterClass>): void;
	onConcatenationEnter?(node: NoParent<Concatenation>): void;
	onConcatenationLeave?(node: NoParent<Concatenation>): void;
	onExpressionEnter?(node: NoParent<Expression>): void;
	onExpressionLeave?(node: NoParent<Expression>): void;
	onQuantifierEnter?(node: NoParent<Quantifier>): void;
	onQuantifierLeave?(node: NoParent<Quantifier>): void;
}
/**
 * Calls the given visitor on the given node and all of its children.
 *
 * If the given visitor throws an error, the traversal will stop and the error will be re-thrown.
 *
 * @param node
 * @param visitor
 */
export function visitAst(node: Node, visitor: VisitAstHandler): void;
export function visitAst(node: NoParent<Node>, visitor: VisitNoParentAstHandler): void;
/**
 * A transform is some algorithm that takes a AST subtree and makes any number of modifications to the given subtree.
 * They cannot see or modify anything outside the given subtree. Transformers are assumed to behave like a set of pure
 * functions.
 *
 * Transformers are always applied bottom-up.
 *
 * The most simple transformer is an empty object (`{}`). This is equivalent to a no-op transformer that does not change
 * the given AST.
 */
export interface Transformer {
	onAlternation?(node: NoParent<Alternation>, context: TransformContext): void;
	onAssertion?(node: NoParent<Assertion>, context: TransformContext): void;
	onCharacterClass?(node: NoParent<CharacterClass>, context: TransformContext): void;
	onConcatenation?(node: NoParent<Concatenation>, context: TransformContext): void;
	onExpression?(node: NoParent<Expression>, context: TransformContext): void;
	onQuantifier?(node: NoParent<Quantifier>, context: TransformContext): void;
}
export interface TransformContext {
	/**
	 * The maximum character of all character sets in the AST.
	 *
	 * If the expression to transform does not contain any characters at the start of the transformation, then this
	 * value will be `0`.
	 */
	readonly maxCharacter: Char;
	/**
	 * Signals that the transformer changed the AST.
	 */
	readonly signalMutation: () => void;
}
/**
 * Creates a new transformer that performs all given transformers in sequentially in order for each node.
 *
 * If only one transformer is given, the returned transformer will be functionally equivalent. If no transformers are
 * given, the returned transformer will be equivalent to a noop transformer.
 *
 * The given iterable can be changed and reused after this function returns.
 *
 * @param transformers
 */
export function combineTransformers(transformers: Iterable<Transformer>): Transformer;
export interface TransformOptions {
	/**
	 * The maximum number of times the transformer will be applied to the AST.
	 *
	 * This is only a maximum. The transformer will be stopped before this number is reach if the AST isn't modified
	 * anymore.
	 *
	 * @default 10
	 */
	maxPasses?: number;
}
/**
 * Transforms the given expression according to the given transformer.
 *
 * __Do not__ use the given `ast` object again after calling this function, the object will be in an undefined state.
 *
 * @param transformer
 * @param ast
 * @param options
 */
export function transform(
	transformer: Transformer,
	ast: NoParent<Expression>,
	options?: Readonly<TransformOptions>
): NoParent<Expression>;
export interface ReadonlyNFA extends TransitionIterableFA {
	readonly nodes: NFA.ReadonlyNodeList;
	readonly options: Readonly<NFA.Options>;
	stateIterator(): FAIterator<NFA.ReadonlyNode>;
	transitionIterator(): FAIterator<NFA.ReadonlyNode, ReadonlyMap<NFA.ReadonlyNode, CharSet>>;
	/**
	 * Create a mutable copy of this NFA.
	 */
	copy(): NFA;
}
/**
 * A [nondeterministic finite automaton](https://en.wikipedia.org/wiki/Nondeterministic_finite_automaton).
 *
 * This class implements epsilon-free NFAs.
 */
export class NFA implements ReadonlyNFA {
	readonly nodes: NFA.NodeList;
	readonly maxCharacter: Char;
	get options(): Readonly<NFA.Options>;
	get isEmpty(): boolean;
	get isFinite(): boolean;
	stateIterator(): FAIterator<NFA.ReadonlyNode>;
	transitionIterator(): FAIterator<NFA.ReadonlyNode, ReadonlyMap<NFA.ReadonlyNode, CharSet>>;
	copy(): NFA;
	test(word: ReadonlyWord): boolean;
	wordSets(): Iterable<CharSet[]>;
	words(): Iterable<Word>;
	toString(): string;
	toRegex(options?: Readonly<ToRegexOptions>): NoParent<Expression>;
	isDisjointWith(other: TransitionIterable, options?: Readonly<IntersectionOptions>): boolean;
	intersectionWordSets(other: TransitionIterable, options?: Readonly<IntersectionOptions>): Iterable<CharSet[]>;
	intersectionWords(other: TransitionIterable, options?: Readonly<IntersectionOptions>): Iterable<Word>;
	/**
	 * Modifies this NFA to accept all words from this NFA and the given FA.
	 *
	 * @param other
	 */
	union(other: TransitionIterable): void;
	/**
	 * Modifies this NFA to accept the concatenation of this NFA and the given FA.
	 *
	 * @param other
	 */
	append(other: TransitionIterable): void;
	/**
	 * Modifies this NFA to accept the concatenation of the given NFA and this FA.
	 *
	 * @param other
	 */
	prepend(other: TransitionIterable): void;
	/**
	 * Modifies this NFA to accept at least `min` and at most `max` concatenations of itself.
	 *
	 * Both `min` and `max` both have to be non-negative integers with `min <= max`.
	 * `max` is also allowed to be `Infinity`.
	 *
	 * @param min
	 * @param max
	 */
	quantify(min: number, max: number): void;
	/**
	 * Removes the empty word from the accepted languages of this NFA.
	 */
	withoutEmptyWord(): void;
	/**
	 * Modifies this NFA such that all prefixes of all accepted words are also accepted.
	 *
	 * If the language of this NFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	prefixes(): void;
	/**
	 * Modifies this NFA such that all suffixes of all accepted words are also accepted.
	 *
	 * If the language of this NFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	suffixes(): void;
	/**
	 * Modifies this NFA such that it accepts the reverse of all words it currently accepts.
	 *
	 * If the language of this NFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	reverse(): void;
	/**
	 * Returns a new NFA which is equivalent to the intersection of the two given FA.
	 *
	 * @param left
	 * @param right
	 * @param options
	 */
	static fromIntersection(
		left: TransitionIterable,
		right: TransitionIterable,
		options?: Readonly<IntersectionOptions & NFA.CreationOptions>
	): NFA;
	/**
	 * Creates a new NFA which matches no words. The language of the returned NFA is empty.
	 *
	 * @param options
	 */
	static empty(options: Readonly<NFA.Options>): NFA;
	/**
	 * Creates a new NFA which matches all words.
	 *
	 * @param options
	 */
	static all(options: Readonly<NFA.Options>): NFA;
	static fromRegex(
		concat: NoParent<Concatenation>,
		options: Readonly<NFA.Options>,
		creationOptions?: Readonly<NFA.FromRegexOptions>
	): NFA;
	static fromRegex(
		expression: NoParent<Expression>,
		options: Readonly<NFA.Options>,
		creationOptions?: Readonly<NFA.FromRegexOptions>
	): NFA;
	static fromRegex(
		alternatives: readonly NoParent<Concatenation>[],
		options: Readonly<NFA.Options>,
		creationOptions?: Readonly<NFA.FromRegexOptions>
	): NFA;
	/**
	 * Creates a new NFA which matches all and only all of the given words.
	 *
	 * @param words
	 * @param options
	 * @param creationOptions
	 */
	static fromWords(
		words: Iterable<ReadonlyWord>,
		options: Readonly<NFA.Options>,
		creationOptions?: Readonly<NFA.CreationOptions>
	): NFA;
	static fromFA(fa: TransitionIterable, creationOptions?: Readonly<NFA.CreationOptions>): NFA;
	static fromTransitionIterator<InputNode>(
		iter: FAIterator<InputNode, ReadonlyMap<InputNode, CharSet>>,
		options: Readonly<NFA.Options>,
		creationOptions?: Readonly<NFA.CreationOptions>
	): NFA;
}
/**
 * A namespace for NFA-specific classes and interfaces.
 *
 * @see {@link NFA} (class)
 */
export namespace NFA {
	interface ReadonlyNode {
		readonly list: ReadonlyNodeList;
		readonly out: ReadonlyMap<ReadonlyNode, CharSet>;
		readonly in: ReadonlyMap<ReadonlyNode, CharSet>;
	}
	interface Node extends ReadonlyNode {
		readonly list: NodeList;
		readonly out: Map<Node, CharSet>;
		readonly in: Map<Node, CharSet>;
	}
	interface ReadonlyNodeList extends Iterable<ReadonlyNode> {
		readonly initial: ReadonlyNode;
		readonly finals: ReadonlySet<ReadonlyNode>;
		/**
		 * Returns the number of nodes reachable from the initial state including the initial state.
		 *
		 * This may include trap states. This will not include unreachable final states.
		 *
		 * This operation has to traverse the whole graph and runs in _O(E + V)_.
		 */
		count(): number;
	}
	class NodeList implements ReadonlyNodeList, Iterable<Node> {
		/**
		 * The initial state of this list.
		 *
		 * The initial state is fixed an cannot be changed or removed.
		 */
		readonly initial: Node;
		/**
		 * The set of final states of this list.
		 */
		readonly finals: Set<Node>;
		constructor();
		/**
		 * Creates a new node associated with this node list.
		 */
		createNode(): Node;
		/**
		 * Adds a transition from `from` to `to` using the given non-empty set of characters.
		 *
		 * If two nodes are already linked, the character sets will be combined.
		 *
		 * @param from
		 * @param to
		 * @param characters
		 */
		linkNodes(from: Node, to: Node, characters: CharSet): void;
		/**
		 * Removes the transition from `from` to `to`.
		 *
		 * If there is no transition from `from` to `to`, an error will be thrown.
		 *
		 * @param from
		 * @param to
		 */
		unlinkNodes(from: Node, to: Node): void;
		/**
		 * All states which cannot be reached from the initial state or cannot reach (or are) a final state, will be
		 * removed.
		 */
		removeUnreachable(): void;
		count(): number;
		[Symbol.iterator](): Iterator<Node>;
	}
	/**
	 * Options for the constraints on how a NFA will be created.
	 */
	interface CreationOptions {
		/**
		 * The maximum number of nodes the NFA creation operation is allowed to create before throwing a
		 * `TooManyNodesError`.
		 *
		 * If the maximum number of nodes is set to `Infinity`, the NFA creation operation may create as many nodes as
		 * necessary to construct the NFA. This might cause the machine to run out of memory. I.e. some REs can only be
		 * represented with a huge number of states (e.g `/a{123456789}/`).
		 *
		 * Note: This limit describes maximum number of __created__ nodes. If nodes are created and subsequently
		 * discard, they will still count toward the limit.
		 *
		 * @default 10000
		 */
		maxNodes?: number;
	}
	interface Options {
		/**
		 * The maximum numerical value any character can have.
		 *
		 * This will be the maximum of all underlying {@link CharSet}s.
		 */
		maxCharacter: Char;
	}
	interface FromRegexOptions extends CreationOptions {
		/**
		 * How to handle assertions when construction the NFA.
		 *
		 * - `"throw"`
		 *
		 *   This method will throw an error when encountering an assertion.
		 *
		 * - `"disable"`
		 *
		 *   This method will replace any assertion with an empty character class, effectively removing it.
		 *
		 * @default "throw"
		 */
		assertions?: "disable" | "throw";
		/**
		 * The number at which the maximum of a quantifier will be assumed to be infinity.
		 *
		 * Quantifiers with a large finite maximum (e.g. `a{1,10000}`) can create huge NFAs with thousands of states.
		 * Any Quantifier with a maximum greater or equal to this threshold will be assumed to be infinite.
		 *
		 * @default Infinity
		 */
		infinityThreshold?: number;
	}
}
export interface ReadonlyDFA extends TransitionIterableFA {
	readonly nodes: DFA.ReadonlyNodeList;
	readonly options: Readonly<DFA.Options>;
	stateIterator(): FAIterator<DFA.ReadonlyNode>;
	transitionIterator(): FAIterator<DFA.ReadonlyNode, ReadonlyMap<DFA.ReadonlyNode, CharSet>>;
	/**
	 * Creates a new DFA equivalent to this one.
	 */
	copy(): DFA;
	/**
	 * Returns whether this and the given DFA are structurally equal meaning that all nodes and all transitions are
	 * equal.
	 *
	 * @param other
	 */
	structurallyEqual(other: ReadonlyDFA): boolean;
}
/**
 * A [deterministic finite automaton](https://en.wikipedia.org/wiki/Deterministic_finite_automaton).
 */
export class DFA implements ReadonlyDFA {
	readonly nodes: DFA.NodeList;
	readonly maxCharacter: Char;
	get options(): Readonly<DFA.Options>;
	get isEmpty(): boolean;
	get isFinite(): boolean;
	stateIterator(): FAIterator<DFA.ReadonlyNode>;
	transitionIterator(): FAIterator<DFA.ReadonlyNode, ReadonlyMap<DFA.ReadonlyNode, CharSet>>;
	test(word: ReadonlyWord): boolean;
	wordSets(): Iterable<CharSet[]>;
	words(): Iterable<Word>;
	toString(): string;
	toRegex(options?: Readonly<ToRegexOptions>): NoParent<Expression>;
	isDisjointWith(other: TransitionIterable, options?: Readonly<IntersectionOptions>): boolean;
	intersectionWordSets(other: TransitionIterable, options?: Readonly<IntersectionOptions>): Iterable<CharSet[]>;
	intersectionWords(other: TransitionIterable, options?: Readonly<IntersectionOptions>): Iterable<Word>;
	copy(): DFA;
	structurallyEqual(other: ReadonlyDFA): boolean;
	/**
	 * [Minimizes](https://en.wikipedia.org/wiki/DFA_minimization) this DFA.
	 */
	minimize(): void;
	/**
	 * Complements this DFA.
	 *
	 * This DFA after calling this function will accept all words that are not accepted by this DFA before calling this
	 * function.
	 */
	complement(): void;
	/**
	 * Modifies this DFA such that all prefixes of all accepted words are also accepted.
	 *
	 * If the language of this DFA is empty, then it will remain empty.
	 *
	 * Unreachable states will be removed by this operation.
	 */
	prefixes(): void;
	/**
	 * Returns a new DFA which is equivalent to the intersection of the two given FA.
	 *
	 * @param left
	 * @param right
	 * @param options
	 */
	static fromIntersection(
		left: TransitionIterable,
		right: TransitionIterable,
		options?: Readonly<IntersectionOptions>
	): DFA;
	/**
	 * Creates a new DFA which matches no words. The language of the returned DFA is empty.
	 *
	 * @param options
	 */
	static empty(options: Readonly<DFA.Options>): DFA;
	/**
	 * Creates a new DFA which matches all words.
	 *
	 * @param options
	 */
	static all(options: Readonly<DFA.Options>): DFA;
	static fromWords(
		words: Iterable<ReadonlyWord>,
		options: Readonly<DFA.Options>,
		creationOptions?: Readonly<DFA.CreationOptions>
	): DFA;
	static fromFA(fa: TransitionIterable, creationOptions?: Readonly<DFA.CreationOptions>): DFA;
	static fromTransitionIterator<InputNode>(
		iter: FAIterator<InputNode, ReadonlyMap<InputNode, CharSet>>,
		options: Readonly<DFA.Options>,
		creationOptions?: Readonly<DFA.CreationOptions>
	): DFA;
}
/**
 * A namespace for DFA-specific classes and interfaces.
 *
 * @see {@link DFA} (class)
 */
export namespace DFA {
	interface ReadonlyNode {
		readonly list: ReadonlyNodeList;
		readonly out: ReadonlyCharMap<ReadonlyNode>;
	}
	interface Node extends ReadonlyNode {
		readonly list: NodeList;
		readonly out: CharMap<Node>;
	}
	interface ReadonlyNodeList extends Iterable<ReadonlyNode> {
		readonly initial: ReadonlyNode;
		readonly finals: ReadonlySet<ReadonlyNode>;
		/**
		 * Returns the number of nodes reachable from the initial state including the initial state.
		 *
		 * This may include trap states. This will not include unreachable final states.
		 *
		 * This operation has to traverse the whole graph and runs in _O(E + V)_.
		 */
		count(): number;
	}
	class NodeList implements ReadonlyNodeList {
		readonly initial: Node;
		readonly finals: Set<Node>;
		constructor();
		createNode(): Node;
		linkNodes(from: Node, to: Node, characters: CharSet | CharRange | Char): void;
		/** @internal */
		_uncheckedLinkNodesWithCharacter(from: Node, to: Node, character: Char): void;
		/** @internal */
		_uncheckedLinkNodesWithCharRange(from: Node, to: Node, characters: CharRange): void;
		/** @internal */
		_uncheckedLinkNodesWithCharSet(from: Node, to: Node, characters: CharSet): void;
		unlinkNodes(from: Node, to: Node): void;
		removeUnreachable(): void;
		count(): number;
		[Symbol.iterator](): IterableIterator<Node>;
	}
	/**
	 * Options for the constraints on how a DFA will be created.
	 */
	interface CreationOptions {
		/**
		 * The maximum number of nodes the DFA creation operation is allowed to create before throwing a
		 * `TooManyNodesError`.
		 *
		 * If the maximum number of nodes is set to `Infinity`, the DFA creation operation may create as many nodes as
		 * necessary to construct the DFA. This might cause the machine to run out of memory. I.e. the conversion from
		 * NFA to DFA may create `O(2^n)` many nodes and an intersection may created `O(n * m)` many.
		 *
		 * Note: This limit describes the maximum number of __created__ nodes. If nodes are created and subsequently
		 * discard, they will still count toward the limit.
		 *
		 * @default 10000
		 */
		maxNodes?: number;
	}
	interface Options {
		/**
		 * The maximum numerical value any character can have.
		 *
		 * This will be the maximum of all underlying {@link CharSet}s.
		 */
		maxCharacter: Char;
	}
}
/**
 * Contains all AST transformer implementations of refa.
 *
 * All transformer factory functions implemented here will optionally take {@link CreationOptions} or a sub-class of it.
 * This can be used to control the behavior of the created transformers.
 *
 * @module
 */
export namespace Transformers {
	interface CreationOptions {
		/**
		 * If `true`, transformers are allowed to reorder alternatives and to change/ignore the laziness of quantifiers.
		 * This may cause the behavior of the regex to change.
		 *
		 * @default false
		 */
		ignoreOrder?: boolean;
		/**
		 * If `true`, transformers are allowed to reduce or increase the ambiguity of the regular expression.
		 *
		 * @default false
		 */
		ignoreAmbiguity?: boolean;
	}
	/**
	 * This transformer will apply all trivial assertion (e.g. `/(?!0)\d/` => `/[1-9]/`) and remove all branches in
	 * assertions that are guaranteed to reject (e.g. `(?=\d+=|-)\w` => `(?=\d+=)\w`).
	 */
	function applyAssertions(_options?: Readonly<CreationOptions>): Transformer;
	/**
	 * This will factor out common prefixes and suffixes in parent nodes.
	 *
	 * Examples:
	 *
	 * - `(?:abc|aba)` => `(?:ab(?:c|a))`
	 * - `(?<!air|after)` => `(?<!a(?:i|fte)r)`
	 *
	 * The order of alternatives and the ambiguity of the regular expression are guaranteed to be preserved. One non-obvious
	 * case where ambiguity is preserved is the case of duplicate alternatives. In this case, a group with multiple empty
	 * alternatives will be left.
	 *
	 * E.g. `(?:abc|abc|abc)` => `(?:abc(?:||))`
	 */
	function factorOut(options?: Readonly<CreationOptions>): Transformer;
	/**
	 * This transformer will simplify the AST by doing trivial inlining operations.
	 *
	 * It will:
	 *
	 * 1. Inline single-alternative alternations in concatenation (e.g. `a(?:b)c` => `abc`).
	 * 2. Inline single-alternation concatenations (e.g. `(?:(?:a|b)|c)` => `(?:a|b|c)`).
	 * 3. Inline constant-one quantifiers (e.g. `ab{1}c` => `abc`).
	 * 4. Remove constant-zero quantifiers (e.g. `ab{0}c` => `ac`).
	 * 5. Inline trivially nested assertions (e.g. `(?!(?<!a))` => `(?<=a)`).
	 * 6. Inline nested assertions at the end of the expression tree (e.g. `(?!a(?=b))` => `(?!ab)`).
	 *
	 * ---
	 *
	 * This transformer should be used in combination with {@link removeDeadBranches} to handle trivial simplifications.
	 */
	function inline(_options?: Readonly<CreationOptions>): Transformer;
	/**
	 * This operation tries to merge as many elements as possible with existing quantifiers.
	 *
	 * Examples:
	 *
	 * - `/a*a/` => `/a+/`
	 * - `/a*(?:a+|c)/` => `/a*(?:a|c)/`
	 */
	function mergeWithQuantifier(options?: Readonly<CreationOptions>): Transformer;
	/**
	 * This tries to simplify how a given sub-expression accepts the empty string. The goal is to modify the sub-expression
	 * such that exactly one path accepts the empty string. This has the emergent result that the operator that causes the
	 * sub-expression to accept the empty string moves closer to the root of the tree.
	 *
	 * Examples:
	 *
	 * - `a(?:b*|d?)` => `a(?:b+|d)?`
	 * - `||a*|b` => `(?:a+|b)?`
	 *
	 * This operation largely ignores the order of alternatives and usually reduces the ambiguity of the expression. If
	 * order or ambiguity have to be preserved, then the effectiveness of this transformer will be greatly reduced.
	 */
	function moveUpEmpty(options?: Readonly<CreationOptions>): Transformer;
	/**
	 * This merges/optimizes nested quantifiers.
	 *
	 * Examples:
	 *
	 * - `(?:a+)*` => `a*`
	 * - `(?:a{2,4})+` => `a{2,}`
	 * - `(?:a{4}){8}` => `a{32}`
	 * - `(?:a*|b+c|f+)*` => `(?:a{1}|b+c|f{1})*`
	 *
	 * This operation largely ignores the order of alternatives and usually reduces the ambiguity of the expression. If
	 * order or ambiguity have to be preserved, then the effectiveness of this transformer will be greatly reduced.
	 */
	function nestedQuantifiers(options?: Readonly<CreationOptions>): Transformer;
	interface PatternEdgeAssertionsCreationOptions extends CreationOptions {
		/**
		 * @default true
		 */
		inline?: boolean;
		/**
		 * @default false
		 */
		remove?: boolean;
	}
	/**
	 * This transformer will only touch assertion that assert characters beyond the edge of the pattern.
	 *
	 * E.g. in `/(?<!\w)(?!\d)\w+(?=\s*<)/` only `(?<!\w)` and `(?=\s*<)` are pattern edge assertions.
	 *
	 * The transformer can inline non-negated assertions (e.g. `/(?<!\w)(?!\d)\w+(?=\s*<)/` => `/(?<!\w)(?!\d)\w+\s*</`)
	 * and/or remove them (e.g. `/(?<!\w)(?!\d)\w+\s*</` => `/(?!\d)\w+\s*</`).
	 *
	 * If both inlining and removal are active, then inlining will be done first, e.g. `a(?=\w)(?!\d)` => `a(?!\d)\w`, which
	 * may prevent some removal. Some assertions will not be removed because another may be inlined later. E.g. the `(?!\d)`
	 * in `(?=\w)a?(?!\d)` will not be removed because the pattern may be transformed to `(?:a|(?=\w))(?!\d)` =>
	 * `a(?!\d)|(?=\w)(?!\d)` which can be inlined to `a(?!\d)|(?!\d)\w` and transformed to `a(?!\d)|[A-Z_a-z]`.
	 *
	 * If neither inlining nor removal are active, then this transformer won't do anything.
	 */
	function patternEdgeAssertions(options?: Readonly<PatternEdgeAssertionsCreationOptions>): Transformer;
	/**
	 * This removes dead branches in the AST.
	 *
	 * Dead branches are parts of the regex that can never accept on any given input string (e.g. `[]a|b` => `b`).
	 *
	 * This operation may produce parent nodes with 0 alternatives. Quantifiers with 0 alternatives and a minimum of 0 will
	 * be replaced with the empty concatenation (e.g. `a(?:[]b)?c` => `ac`).
	 *
	 * ---
	 *
	 * This transformer should be used in combination with {@link inline} to handle trivial simplifications.
	 */
	function removeDeadBranches(_options?: Readonly<CreationOptions>): Transformer;
	/**
	 * This will remove all assertions that are known to always reject/accept no matter the input string.
	 */
	function removeUnnecessaryAssertions(_options?: Readonly<CreationOptions>): Transformer;
	interface RemoveAssertionsCreationOptions extends CreationOptions {
		/**
		 * @default "empty-set"
		 */
		replacement?: "empty-set" | "empty-word";
	}
	/**
	 * This transformer will all assertions with either the empty set or the empty word.
	 */
	function replaceAssertions(options?: Readonly<RemoveAssertionsCreationOptions>): Transformer;
	/**
	 * Sorts adjacent assertions such that lookbehinds are always to the right of lookaheads.
	 *
	 * This is operation may be necessary for other transformers to pick up on certain patterns.
	 *
	 * E.g. `(?=a)(?!b)(?<!c)(?<=d)` => `(?<!c)(?<=d)(?=a)(?!b)`
	 */
	function sortAssertions(_options?: Readonly<CreationOptions>): Transformer;
	/**
	 * Combines single-character alternatives.
	 *
	 * This rule will try to combine as many character classes as possible to simplify the regular expression.
	 *
	 * E.g. `a|b|c` => `[abc]`.
	 */
	function unionCharacters(options?: Readonly<CreationOptions>): Transformer;
}
/**
 * Classes and functions to convert JavaScript RegExp to refa AST and vise versa.
 *
 * All classes and functions in this module/namespace are specific to JavaScript regular expressions as defined by the
 * ECMAScript standard.
 *
 * @see {@link Parser}: A class to convert from JS RegExp to refa AST.
 * @see {@link toLiteral}: A function to convert from refa AST to JS RegExp.
 *
 * @module
 */
export namespace JS {
	type BoundaryAssertion = WordBoundaryAssertion | TextBoundaryAssertion;
	interface WordBoundaryAssertion {
		kind: "word";
		negate: boolean;
	}
	interface TextBoundaryAssertion {
		kind: "end" | "start";
	}
	function createAssertion(assertion: Readonly<BoundaryAssertion>, flags: Readonly<Flags>): NoParent<Element>;
	type PredefinedCharacterSet =
		| AnyCharacterSet
		| DigitCharacterSet
		| PropertyCharacterSet
		| SpaceCharacterSet
		| WordCharacterSet;
	interface AnyCharacterSet {
		kind: "any";
	}
	interface DigitCharacterSet {
		kind: "digit";
		negate: boolean;
	}
	interface PropertyCharacterSet {
		kind: "property";
		key: string;
		value: string | null;
		negate: boolean;
	}
	interface SpaceCharacterSet {
		kind: "space";
		negate: boolean;
	}
	interface WordCharacterSet {
		kind: "word";
		negate: boolean;
	}
	/**
	 * Creates a new character set with the characters equivalent to a JavaScript regular expression character set.
	 *
	 * @param chars The characters in the set.
	 * @param flags The flags of the pattern.
	 */
	function createCharSet(
		chars: Iterable<Char | CharRange | Readonly<PredefinedCharacterSet>>,
		flags: Readonly<Flags>
	): CharSet;
	interface ToLiteralOptions {
		/**
		 * An optional template for the flags of the JavaScript RegExp literal to be created.
		 *
		 * All flags that are set to `false` are guaranteed to be disabled in the created literal. Likewise, all flags that
		 * are set to `true` are guaranteed to be enabled in the created literal.
		 *
		 * Flags that are `undefined` will be enabled/disabled depending on the implementation. While no guarantees are
		 * given, the implementation will generally try to choose flags such that it can create literal that is as
		 * small/simple as possible.
		 *
		 * If the constraints on flags defined here make it impossible to create a literal, an error will be thrown.
		 */
		flags?: Flags;
		/**
		 * This will force the function to print characters as fast as possible.
		 *
		 * Literals created with this option will usually be created about 10x faster but the result will usually be very
		 * hard to read. The is option is intended to provide performance benefits when readability is not a concern.
		 *
		 * @default false
		 */
		fastCharacters?: boolean;
	}
	/**
	 * Converts the given AST or AST subtree into a JS literal.
	 *
	 * The returned literal will be a literal representation of the given AST. However, assertions maybe converted to
	 * builtin JS RegExp assertions (e.g `\b`, `$`) instead of using the literal lookahead/lookbehind form.
	 */
	function toLiteral(concat: NoParent<Concatenation>, options?: Readonly<ToLiteralOptions>): Literal;
	function toLiteral(expression: NoParent<Expression>, options?: Readonly<ToLiteralOptions>): Literal;
	function toLiteral(alternatives: readonly NoParent<Concatenation>[], options?: Readonly<ToLiteralOptions>): Literal;
	/**
	 * A partial set of RegExp flags.
	 */
	interface Flags {
		/** @default false */
		dotAll?: boolean;
		/** @default false */
		global?: boolean;
		/** @default false */
		ignoreCase?: boolean;
		/** @default false */
		multiline?: boolean;
		/** @default false */
		sticky?: boolean;
		/** @default false */
		unicode?: boolean;
	}
	/**
	 * A light-weight representation of a
	 * [JavaScript RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp) object.
	 *
	 * This interface only requires the `source` and `flags` properties of a RegExp object.
	 */
	interface Literal {
		readonly source: string;
		readonly flags: string;
	}
	interface ParseOptions {
		/**
		 * The maximum number of words a backreference can be replaced by.
		 *
		 * Set this to 0 to disable resolving backreferences.
		 *
		 * @default 100
		 */
		maxBackreferenceWords?: number;
		/**
		 * How to the parser will handle unresolved backreferences.
		 *
		 * - `"disable"`
		 *
		 *   The parser will replace all backreferences with an empty character class. This will cause all paths containing
		 *   a backreference to be (effectively) removed.
		 *
		 *   E.g. `(a*)(\1|b)` will be parsed as `(a*)([]|b)` which is equivalent to `a*b`.
		 *
		 * - `"throw"`
		 *
		 *   The parser will throw an error when encountering a backreference that cannot be removed.
		 *
		 *   E.g. `(a*)b\1` will throw but `(a*)[^\s\S]\1` will not because the backreference will be removed anyway because
		 *   of the empty character class.
		 *
		 * Backreferences that have been resolved are not affected by this option.
		 *
		 * @default "throw"
		 */
		backreferences?: "disable" | "throw";
		/**
		 * How the parser will handle assertions.
		 *
		 * - `"parse"`
		 *
		 *   The parser will translate every assertion literally to an equivalent RE AST representation. Builtin assertions
		 *   (e.g. `\b`, `$`) will be transformed into equivalent assertions.
		 *
		 * - `"disable"`
		 *
		 *   The parser will disable all assertion by replacing them with an empty character class. This will cause all
		 *   paths containing a assertion to be (effectively) removed.
		 *
		 * - `"throw"`
		 *
		 *   The parser will throw an error when encountering a assertion that cannot be removed.
		 *
		 *   E.g. `a\B` will throw but `a([]\b)(\b){0}` will not because none of the `\b`s can be reached.
		 *
		 * @default "parse"
		 */
		assertions?: "parse" | "disable" | "throw";
		/**
		 * By default, the parser will try to optimize the generated RE as much as possible.
		 *
		 * If set to `true`, all trivial optimizations will be disabled. This includes:
		 *
		 * - Removing alternatives where all paths go through an empty character class.
		 * - Removing constant 0 and constant 1 quantifiers.
		 * - Inlining single-alternative groups.
		 *
		 * These optimization might prevent that certain backreferences or assertions from throwing an error.
		 *
		 * @default false
		 */
		disableOptimizations?: boolean;
		/**
		 * The maximum number of nodes the parser is allowed to create.
		 *
		 * If the regexes requires more nodes, a {@link TooManyNodesError} will be thrown.
		 *
		 * @default 10000
		 */
		maxNodes?: number;
	}
	interface RegexppAst {
		readonly pattern: AST.Pattern;
		readonly flags: AST.Flags;
	}
	type ParsableElement = AST.Group | AST.CapturingGroup | AST.Pattern | AST.Alternative;
	interface ParseResult {
		expression: Expression;
		maxCharacter: Char;
	}
	/**
	 * Converts JS RegExp to refa's RE AST format.
	 */
	class Parser {
		/**
		 * The literal of the parser instance.
		 */
		readonly literal: Literal;
		/**
		 * The parsed AST of the literal this parser works on.
		 *
		 * While not explicitly typed that way, the parser will assume that the AST is readonly and makes optimizations
		 * based on that assumption. It is not safe to change the AST in any way.
		 */
		readonly ast: RegexppAst;
		/**
		 * The maximum character of all character sets in the parsed AST.
		 *
		 * This value will also be returned as part of the {@link ParseResult}.
		 */
		readonly maxCharacter: Char;
		/**
		 * Creates a new parser from the given literal.
		 *
		 * This function will throw a `SyntaxError` if the given literal is not a valid RegExp literal according to the
		 * given RegExp parser options.
		 *
		 * @param literal
		 * @param parserOptions
		 */
		static fromLiteral(literal: Literal, parserOptions?: RegExpParser.Options): Parser;
		/**
		 * Creates a new parser from the given [regexpp](https://github.com/mysticatea/regexpp) AST.
		 *
		 * When the JS RegExp has already been parsed using regexpp, this method can be used to avoid parsing the regex
		 * again.
		 *
		 * The given AST is not allowed to be changed during the lifetime of the returned parser.
		 *
		 * @param ast
		 */
		static fromAst(ast: RegexppAst): Parser;
		/**
		 * Parsed the entire literal.
		 */
		parse(options?: Readonly<ParseOptions>): ParseResult;
		/**
		 * Parses a specific element of the literal.
		 */
		parseElement(element: ParsableElement, options?: Readonly<ParseOptions>): ParseResult;
	}
}
export namespace Words {
	/**
	 * Converts the given array of UTF16 character codes into a string.
	 *
	 * All numbers in the given array must be between 0 (inclusive) and 65535 = 0xFFFF (inclusive).
	 *
	 * @param word
	 */
	function fromUTF16ToString(word: ReadonlyWord): string;
	/**
	 * Converts the given array of Unicode code points into a string.
	 *
	 * All numbers in the given array must be between 0 (inclusive) and 1114111 = 0x10FFFF (inclusive).
	 *
	 * @param word
	 */
	function fromUnicodeToString(word: ReadonlyWord): string;
	/**
	 * Converts the given string into an array of UTF16 character codes.
	 *
	 * All numbers in the returned array are guaranteed to be between 0 (inclusive) and 65535 = 0xFFFF (inclusive).
	 *
	 * @param string
	 */
	function fromStringToUTF16(string: string): Word;
	/**
	 * Converts the given string into an array of Unicode code points.
	 *
	 * All numbers in the returned array are guaranteed to be between 0 (inclusive) and 1114111 = 0x10FFFF (inclusive).
	 *
	 * @param string
	 */
	function fromStringToUnicode(string: string): Word;
	/**
	 * Iterates all words which can be constructed from the given word set (array of character sets).
	 *
	 * @param wordSet
	 */
	function wordSetToWords(wordSet: readonly CharSet[]): Iterable<Word>;
	/**
	 * Returns the most humanly readable character in the given character set. Which character is picked is entirely
	 * implementation-defined but, generally, word characters will be picked over non-word characters and printable
	 * characters will be picked over non-printable characters.
	 *
	 * If the given character set is empty, `undefined` will be returned.
	 *
	 * @param set
	 */
	function pickMostReadableCharacter(set: CharSet): Char | undefined;
	/**
	 * Returns a word of the given word set that is the most humanly readable.
	 *
	 * If at least one of the given character sets is empty, `undefined` will be returned.
	 *
	 * @param wordSet
	 */
	function pickMostReadableWord(wordSet: Iterable<CharSet>): Word | undefined;
}
